## HTTP 완벽가이드

### :seven: 장 Cache

간단하게 요약해보자. 

캐시 :money_with_wings: 를 쓰는 이유?  

* 불필요한 데이터 전송 방지
* 대역폭 병목 방지
* 갑작스런 요청에 대한 쇄도를 방지
* 거리로 인한 지연(latency)를 방지

캐시는 그래서 적중과 부적중, 재검사가가 :arrow_backward: 존재한다~!  

* 적중: 그냥 캐시서버에 있는거 쓰면 된다
* 부적중: 캐시서버에 없으면 본래 서버에서 꺼내와서 캐시서버에 저장하면 된다
* 재검사: `If-Modified-Since` 헤더를 활용해서 캐시된 시간 이후에 변경되었는지 확인하는 방법이다
  * 만일 여기서 적중시, Client에게 **304(Not Modified)**를
  * 부적중시, 서버는 콘텐츠와 함께 **200(Ok)**를
  * 객체가 삭제시, **404(Not Found)**를

#### 캐시 토폴로지

* 개인전용 캐시
  * 흔히 사용하는 웹브라우저에서 일반적인 사용자가 `임시 파일` 로 불리우는 것들
* 공용 캐시
  * 일명 **프락시 캐시**라고 하며, 여러 사용자가 같이 접근할 수 있는 파일이다

#### 캐시 처리 단계

기본적인 캐시를 처리하는 방법 :arrow_up_down: .!  

1. 요청 받기: 네트워크로부터 받은 요청 메세지를 읽는다
2. 파싱: 캐시는 메세지를 파싱하여 URL과 헤더들을 추출한다
3. 검색: 캐시는 로컬 복사본이 있는지 검사하고, 없다면 가져온다
4. 신선도 검사: 캐시된 사본이 신선한지 물어보고, 아니라면 변경사항을 서버에게 물어본다
5. 응답 생성: 캐시는 새로운 헤더와 캐시된 본문으로 응답메세지를 받는다
6. 발송: 네트워크를 통해 응답을 클라이언트에게 돌려준다
7. 로깅: 선택적으로, 이러한 트랜잭션 과정을 로그로 남긴다

<div>
  <img src="img/cache_hit.png" text-align="center" />
</div>


#### 그럼 어떻게 사본을 신선하게 유지할 수 있을까?

* 문서 만료시간 :alarm_clock: 정의: `Expires` 헤더와 `Cache-Control` 이라는 특별한 헤더를 사용한다
  * Cache-Control: max-age=22 이런식으로 캐시에 만료 날짜를 명시한다
  * Expires 라는 절대 유효기간을 명시한다
* 서버 재검사
  * 캐시된 문서가 만료되었음을 서버에게 물어보는 것
  * 검사 결과 콘텐츠 변경되었으면 **서버로부터 가져오면 되**는 거고
  * 콘텐츠 변경이 없다면 **새 만료일을 포함한 새로운 헤더만 가져오면 됨**

그러면 재검사를 어떻게 하는가?  

가장 흔히쓰이는 것은 `If-Modified-Since` : 주어진 날짜로부터 수정되었다면 서버는 요청을 처리한다.!  

만약 수정이 안되었으면 **304(Not Modified)**를 응답!  

다음으로는 `If-None-Match` : 일종의 버젼정보(`ETag`)를 바탕으로 최신 데이터인지 확인하는 방식.!  

웬만해서는 2가지 방식을 모두 같이 사용하는 것이 좋다 ㅎㅎ. 



#### 그 외로

캐시를 제어하는 방식, 캐시의 신선도를 계산하는 방식이 기술되어 있는데,  

관심이 있다면 더 읽어봐도 좋다 ㅎㅎ :smile: